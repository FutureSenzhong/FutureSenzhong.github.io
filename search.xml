<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[删除Git远程仓库文件]]></title>
    <url>%2F2018%2F12%2F12%2F%E5%88%A0%E9%99%A4git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1.先在本地git清除文件夹1234# 查看本地版本库里的文件 git status# 删除多余的文件 git rm xxx(xxx表文件名) -rf ( -r 当给出主目录名时允许递归删除) 2.本地提交更改12# 提交更新 git commit -m''(-m 备注) 3.最后push到远程仓库12# 更新远程仓库内容 git push 4.最后查看远程仓库内容是否和本地一致]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于阿里云服务器CentOS系统搭建Hexo博客git自动化部署]]></title>
    <url>%2F2018%2F12%2F11%2F%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8CentOS%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2git%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[前言本文介绍的是如何在CentOS系统上使用Hexo博客框架搭建一个完全属于自己的博客系统。 CentOS是什么?CentOS（Community Enterprise Operating System）是Linux发行版之一，它是来自于Red Hat Enterprise Linux依照开放源代 码规定发布的源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用。两者的不同，在于CentOS并不包含封閉源码软件。CentOS 对上游代码的主要修改是为了移除不能自由使用的商标。2014年，CentOS宣布与Red Hat合作，但CentOS将会在新的委员会下继续运作，并不受RHEL的影响。 Hexo是什么?Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo使用Node.js来渲染页面，因此渲染速度极快。只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。同时，Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 Nginx是什么?Nginx是一个 Web服务器，也可以用作反向代理，负载平衡器和 HTTP缓存。该软件由 Igor Sysoev 创建，并于2004年首次公开发布。同名公司成立于2011年，以提供支持。Nginx是一款面向性能设计的HTTP服务器，相较于Apache、lighttpd具有占有内存少，稳定性高等优势。与旧版本（&lt;=2.2）的Apache不同，Nginx不采用每客户机一线程的设计模型，而是充分使用异步逻辑从而削减了上下文调度开销，所以并发服务能力更强。整体采用模块化设计，有丰富的模块库和第三方模块库，配置灵活。 在Linux操作系统下，Nginx使用epoll事件模型，得益于此，Nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于epoll的高效事件模型kqueue。 Git是什么?git是用于Linux内核开发的版本控制工具。与CVS、Subversion一类的集中式版本控制工具不同，它采用了分布式版本库的作法，不需要服务器端软件，就可以运作版本控制，使得源代码的发布和交流极其方便。git的速度很快，这对于诸如Linux内核这样的大项目来说自然很重要。git最为出色的是它的合并追踪（merge tracing）能力。实际上内核开发团队决定开始开发和使用git来作为内核开发的版本控制系统的时候，世界上开源社区的反对声音不少，最大的理由是git太艰涩难懂，从git的内部工作机制来说，的确是这样。但是随着开发的深入，git的正常使用都由一些友善的命令稿来执行，使git变得非常好用。现在，越来越多的著名项目采用git来管理项目开发，例如：wine、U-boot等。 Node.js是什么？Node.js是一个能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。Node.js采用Google开发的V8运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的事实应用程序。Node.js的出现使JavaScript也能用于服务器端编程。Node.js含有一系列内置模块，使得程序可以脱离Apache HTTP Server或IIS，作为独立服务器运行。 总体思路以下为了统一说法，统一将云主机称为服务端，将本地电脑称为客户端。本次搭建博客需要在客户端以及服务端进行一系列配置。先说一下整体的实现思路。总的来说分两大步。 第一步，在客户端进行以下工作： 安装Git服务以及配置Git 安装nodejs 安装Hexo框架 第二步，在服务端进行以下工作： 安装Nginx服务 安装Git服务以及nodejs 搭建Git服务器以及配置自动部署 软件下载现在，罗列一下过程所需的软件： Git for Windows Git for Mac Nodejs for Windows putty for Windows 客户端配置安装Git以及进行相关配置1、首先通过前面提供的链接下载Git客户端，然后进行安装。 2、安装完成之后，打开Git Bash进行以下配置.在客户端输入以下代码，生成SSH KEY,用于免密登录服务器，更新服务器git仓库。 12# 将此处的"youremail"替换成自己服务器 “仓库名@ip”ssh-keygen -t rsa -C "youremail" 接着继续输入cat ~/.ssh/id_rsa.pub,然后将得到的秘钥先复制一下，待会服务器配置需要用到。 1cat ~/.ssh/id_rsa.pub 安装Nodejs通过前面提供的链接下载Nodejs，然后进行安装。安装完成后，输入node -v以及npm -v查看node以及npm的版本信息。12node -vnpm -v 安装Hexo框架接下来，就是重头戏：安装Hexo框架了。首先，继续在刚刚打开的Git Bash里面输入以下代码，通过npm进行全局安装hexo 框架。 1npm install -g hexo-cli 安装完hexo框架，就可以开始初始化hexo了，选择一个目录存放你的博客文件， 然后把Git Bash切换到那个目录。接着，输入hexo init blog进行初始化hexo并创建一个blog文件。1hexo init blog 初始化完毕之后，打开博客根目录的package.json文件，在dependencies的配置中，追加一项：”hexo-deployer-git”: “^0.3.1”，如下图，然后，返回Git Bash,先输入cd blog，在输入npm install进行包的安装。(git的新版本不用安装)1vim package.json 安装完包之后，接着在Git Bash输入：hexo s，然后在浏览器输入localhost:4000,就可以看到hexo已经搭建成功了.1hexo s 至此，客户端的配置就告一段落了。接下来开始服务端的配置。 服务端配置首先，进行服务端的系统更新。待更新完系统之后再进行以下操作。(注：putty软件的粘贴快捷键为：“Shift”+“Insert”)输入以下代码，可进行系统更新：1yum update -y 更新完系统，输入以下代码，可查看系统版本： 1cat /etc/centos-release 安装Nginx安装Nginx分为以下几步。第一，配置Nginx官方源。第二，安装Nginx。第三，配置Nginx配置文件。 1、配置Nginx官方源输入以下代码，新建一个文件以配置Nginx源12vi /etc/yum.repos.d/nginx.repo 在打开的文件中输入以下代码，输入完毕之后，按 “esc” 键退出编辑模式， 输入 “:wq” 保存退出。123456[nginx]name=nginx repobaseurl=http://nginx.org/packages/mainline/centos/7/$basearch/gpgcheck=0enabled=1 2、安装Nginx输入以下代码进行安装。12yum install nginx -y 3、启动Nginx并设置开机自启输入以下代码:12systemctl start nginxsystemctl enable nginx 进行到这里，你已经可以把服务器ip复制到浏览器进行访问了~安装成功的话就会出现下面的欢迎界面。 4、配置Nginx接下来，需要修改一下nginx的相关配置，包括设置网站根目录以及配置域名。输入以下代码，打开Nginx的配置文件。(注：此处假定读者已完成了域名备案以及域名解析。)1vi /etc/nginx/conf.d/default.conf 在server配置中将“/usr/share/nginx/html”改为“/usr/share/nginx/html/blog”。 （若是空文件先执行其他操作） 至此，Nginx的配置就基本完成了。 安装Nodejs输入以下代码进行Nodejs的安装。1yum install nodejs 安装Git以及进行相关配置1、输入以下代码，进行Git的安装12yum install git 2、创建git用户以及设置密码输入以下代码：1234#创建用户,用户名为gitadduser git#设置密码passwd git 3、把git用户添加到sudo用户组中输入以下代码sudo vi /etc/sudoers，打开sudoers文件，输入:/root进行搜索，搜索到代码行root ALL=(ALL) ALL,然后在这一行下添加以下代码git ALL=(ALL) ALL。输入完毕之后，按wq!强制保存退出vi。1sudo vi /etc/sudoers 4、切换到git用户，添加SSH Key文件并且设置相应的读写与执行权限。输入以下代码：123456# 切换用户su git# 创建目录mkdir ~/.ssh# 新建文件vim ~/.ssh/authorized_keys 然后把之前在客户端设置的SSH Key,复制到authorized_keys文件中，保存后退出。 接下来设置文件权限，把authorized_keys文件设置成只有属主有读写权限，把ssh目录设置为只有属主有读、写、执行权限。代码如下：12chmod 600 ~/.ssh/authorized_keyschmod 700 ~/.ssh 设置完后，返回客户端，打开Git Bash，输入以下代码，测试是否能连接上服务器：12# ServerIP为你自己服务器的ipssh -v git@ServerIP 5、重新回到服务器，在网站根目录新建一个blog文件夹，用于客户端上传文件，并且把该文件授权给git用户。代码如下：123# 使用sudo指令，需要输入git用户的密码sudo mkdir -p /usr/share/nginx/html/blogsudo chown -R git:git /usr/share/nginx/html/blog 在服务器上初始化一个git裸库切换到git用户，然后切换到git用户目录，接着初始化裸库，代码如下：123su gitcd ~git init --bare blog.git 接着新建一个post-receive文件 1vim ~/blog.git/hooks/post-receive 然后在该文件中输入以下内容：12#！/bin/shgit --work-tree=/usr/share/nginx/html/blog --git-dir=/home/git/blog.git checkout -f 保存退出之后，再输入以下代码，赋予该文件可执行权限。1chmod +x ~/blog.git/hooks/post-receive 7、返回客户端，设置博客根目录下的_config.yml文件。12345deploy: type: git repo: git@SERVER:/home/git/blog.git #此处的SERVER需改为你自己服务器的ip branch: master #这里填写分支 message: #提交的信息 保存后，在博客根目录打开Git Bash，输入以下命令：12# clean清除缓存，g生成静态文件资源，d部署到远程网站仓库hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 部署完毕之后，即可在浏览器输入你的服务器ip进行访问你的博客了。ps:新建一个博客：hexo new hello，就会在根目录suorce文件中的_posts文件夹中生成一篇hello博客，然后就可以编辑博客了。关于博客中引入图片的问题，需要下载一个img插件，然后命令生成hello时就会同时生成一个同名的hello文件夹用来存储图片，将图片放置在此文件夹中，博客中引入的图片就可以在网站正常显示了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>CentOS+Hexo博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转PyCharm]]></title>
    <url>%2F2018%2F10%2F20%2F%E7%8E%A9%E8%BD%ACPyCharm%2F</url>
    <content type="text"><![CDATA[简介PyCharm是由JetBrains公司开发的提供给Python专业的开发者的一个集成开发环境，它最大的优点是能够大大提升Python开发者的工作效率，为开发者集成了很多用起来非常顺手的功能，包括代码调试、高亮语法、代码跳转、智能提示、自动补全、单元测试、版本控制等等。此外，PyCharm还提供了对一些高级功能的支持，包括支持基于Django框架的Web开发、。 PyCharm的安装可以在JetBrains公司的官方网站找到PyCharm的下载链接，有两个可供下载的版本一个是社区版一个是专业版，社区版在Apache许可证下发布，专业版在专用许可证下发布（需要购买授权下载后可试用30天），其拥有许多额外功能。安装PyCharm需要有JRE（Java运行时环境）的支持，如果没有可以在安装过程中选择在线下载安装。 说明：如果你是一名学生，希望购买PyCharm来使用，可以看看教育优惠官方申请指南。 首次使用的设置第一次使用PyCharm时，会有一个导入设置的向导，如果之前没有使用PyCharm或者没有保存过设置的就直接选择“Do not import settings”进入下一步即可。 专业版的PyCharm是需要激活的，强烈建议为优秀的软件支付费用，如果不用做商业用途，我们可以暂时选择试用30天或者使用社区版的PyCharm。 接下来是选择UI主题，这个可以根据个人喜好进行选择。 再接下来是创建可以在终端（命令行）中使用PyCharm项目的启动脚本，当然也可以直接跳过这一步。 然后可以选择需要安装哪些插件，我们可以暂时什么都不安装等需要的时候再来决定。 用PyCharm创建项目点击上图中的“Start using PyCharm”按钮就可以开始使用PyCharm啦，首先来到的是一个欢迎页，在欢迎页上我们可以选择“创建新项目”、“打开已有项目”和“从版本控制系统中检出项目”。 如果选择了“Create New Project”来创建新项目就会打一个创建项目的向导页。 在如上图所示的界面中，我们可以选择创建项目的模板，包括了纯Python项目、基于各种不同框架的Web项目、Web前端项目、跨平台项目等各种不同的项目模板。如果选择Python的项目，那么有一个非常重要的设定是选择“New environment…”（创建新的虚拟环境）还是使用“Existing Interpreter”（已经存在的解释器）。前者肯定是更好的选择，因为新的虚拟环境不会对系统环境变量中配置的Python环境造成影响，简单举个例子就是你在虚拟环境下安装或者更新了任何三方库，它并不会对系统原有的Python解释器造成任何的影响，但代价是需要额外的存储空间来建立这个虚拟环境。 项目创建完成后就可以开始新建各种文件来书写Python代码了。 在工作窗口的右键菜单中可以找到“Run …”和“Debug …”菜单项，通过这两个菜单项我们就可以运行和调试我们的代码啦。建议关注一下菜单栏中的“Code”、“Refactor”和“Tools”菜单，这里面为编写Python代码提供了很多有用的帮助，我们在后面也会陆续为大家介绍这些功能。]]></content>
      <categories>
        <category>Pycharm</category>
      </categories>
      <tags>
        <tag>PyCharm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年我们踩过的那些坑]]></title>
    <url>%2F2018%2F10%2F20%2F%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E8%B8%A9%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[坑01 - 整数比较的坑在 Python 中一切都是对象，整数也是对象，在比较两个整数时有两个运算符==和is，它们的区别是： is比较的是两个整数对象的id值是否相等，也就是比较两个引用是否代表了内存中同一个地址。 ==比较的是两个整数对象的内容是否相等，使用==时其实是调用了对象的__eq__()方法。 知道了is和==的区别之后，我们可以来看看下面的代码，了解Python中整数比较有哪些坑： 123456789101112131415161718192021222324def main(): x = y = -1 while True: x += 1 y += 1 if x is y: print('%d is %d' % (x, y)) else: print('Attention! %d is not %d' % (x, y)) breaktruetruetrue x = y = 0 while True: x -= 1 y -= 1 if x is y: print('%d is %d' % (x, y)) else: print('Attention! %d is not %d' % (x, y)) breakif __name__ == '__main__': main() 上面代码的部分运行结果如下图所示，出现这个结果的原因是Python出于对性能的考虑所做的一项优化。对于整数对象，Python把一些频繁使用的整数对象缓存起来，保存到一个叫small_ints的链表中，在Python的整个生命周期内，任何需要引用这些整数对象的地方，都不再重新创建新的对象，而是直接引用缓存中的对象。Python把频繁使用的整数对象的值定在[-5, 256]这个区间，如果需要这个范围的整数，就直接从small_ints中获取引用而不是临时创建新的对象。因为大于256或小于-5的整数不在该范围之内，所以就算两个整数的值是一样，但它们是不同的对象。 当然仅仅如此这个坑就不值一提了，如果你理解了上面的规则，我们就再看看下面的代码。 1234567891011121314import disa = 257def main(): b = 257 # 第6行 c = 257 # 第7行 print(b is c) # True print(a is b) # False print(a is c) # Falseif __name__ == "__main__": main() 程序的执行结果已经用注释写在代码上了。够坑吧！看上去a、b和c的值都是一样的，但是is运算的结果却不一样。为什么会出现这样的结果，首先我们来说说Python程序中的代码块。所谓代码块是程序的一个最小的基本执行单位，一个模块文件、一个函数体、一个类、交互式命令中的单行代码都叫做一个代码块。上面的代码由两个代码块构成，a = 257是一个代码块，main函数是另外一个代码块。Python内部为了进一步提高性能，凡是在一个代码块中创建的整数对象，如果值不在small_ints缓存范围之内，但在同一个代码块中已经存在一个值与其相同的整数对象了，那么就直接引用该对象，否则创建一个新的对象出来，这条规则对不在small_ints范围的负数并不适用，对负数值浮点数也不适用，但对非负浮点数和字符串都是适用的，这一点读者可以自行证明。所以 b is c返回了True，而a和b不在同一个代码块中，虽然值都是257，但却是两个不同的对象，is运算的结果自然是False了。为了验证刚刚的结论，我们可以借用dis模块（听名字就知道是进行反汇编的模块）从字节码的角度来看看这段代码。如果不理解什么是字节码，可以先看看《谈谈 Python 程序的运行原理》)这篇文章。可以先用import dis导入dis模块并按照如下所示的方式修改代码。 123if __name__ == "__main__": main() dis.dis(main) 代码的执行结果如下图所示。可以看出代码第6行和第7行，也就是main函数中的257是从同一个位置加载的，因此是同一个对象；而代码第9行的a明显是从不同的地方加载的，因此引用的是不同的对象。 如果还想对这个问题进行进一步深挖，推荐大家阅读《Python整数对象实现原理》这篇文章。 坑02 - 嵌套列表的坑Python中有一种内置的数据类型叫列表，它是一种容器，可以用来承载其他的对象（准确的说是其他对象的引用），列表中的对象可以称为列表的元素，很明显我们可以把列表作为列表中的元素，这就是所谓的嵌套列表。嵌套列表可以模拟出现实中的表格、矩阵、2D游戏的地图（如植物大战僵尸的花园）、棋盘（如国际象棋、黑白棋）等。但是在使用嵌套的列表时要小心，否则很可能遭遇非常尴尬的情况，下面是一个小例子。 12345678910111213def main(): names = ['关羽', '张飞', '赵云', '马超', '黄忠'] subjs = ['语文', '数学', '英语'] scores = [[0] * 3] * 5 for row, name in enumerate(names): print('请输入%s的成绩' % name) for col, subj in enumerate(subjs): scores[row][col] = float(input(subj + ': ')) print(scores)if __name__ == '__main__': main() 我们希望录入5个学生3门课程的成绩，于是定义了一个有5个元素的列表，而列表中的每个元素又是一个由3个元素构成的列表，这样一个列表的列表刚好跟一个表格是一致的，相当于有5行3列，接下来我们通过嵌套的for-in循环输入每个学生3门课程的成绩。程序执行完成后我们发现，每个学生3门课程的成绩是一模一样的，而且就是最后录入的那个学生的成绩。 要想把这个坑填平，我们首先要区分对象和对象的引用这两个概念，而要区分这两个概念，还得先说说内存中的栈和堆。我们经常会听人说起“堆栈”这个词，但实际上“堆”和“栈”是两个不同的概念。众所周知，一个程序运行时需要占用一些内存空间来存储数据和代码，那么这些内存从逻辑上又可以做进一步的划分。对底层语言（如C语言）有所了解的程序大都知道，程序中可以使用的内存从逻辑上可以为五个部分，按照地址从高到低依次是：栈（stack）、堆（heap）、数据段（data segment）、只读数据段（static area）和代码段（code segment）。其中，栈用来存储局部、临时变量，以及函数调用时保存现场和恢复现场需要用到的数据，这部分内存在代码块开始执行时自动分配，代码块执行结束时自动释放，通常由编译器自动管理；堆的大小不固定，可以动态的分配和回收，因此如果程序中有大量的数据需要处理，这些数据通常都放在堆上，如果堆空间没有正确的被释放会引发内存泄露的问题，而像Python、Java等编程语言都使用了垃圾回收机制来实现自动化的内存管理（自动回收不再使用的堆空间）。所以下面的代码中，变量a并不是真正的对象，它是对象的引用，相当于记录了对象在堆空间的地址，通过这个地址我们可以访问到对应的对象；同理，变量b是列表容器的引用，它引用了堆空间上的列表容器，而列表容器中并没有保存真正的对象，它保存的也仅仅是对象的引用。 12a = object()b = ['apple', 'pitaya', 'grape'] 知道了这一点，我们可以回过头看看刚才的程序，我们对列表进行[[0] * 3] * 5操作时，仅仅是将[0, 0, 0]这个列表的地址进行了复制，并没有创建新的列表对象，所以容器中虽然有5个元素，但是这5个元素引用了同一个列表对象，这一点可以通过id函数检查scores[0]和scores[1]的地址得到证实。所以正确的代码应该按照如下的方式进行修改。 1234567891011121314def main(): names = ['关羽', '张飞', '赵云', '马超', '黄忠'] subjs = ['语文', '数学', '英语'] scores = [[]] * 5 for row, name in enumerate(names): print('请输入%s的成绩' % name) scores[row] = [0] * 3 for col, subj in enumerate(subjs): scores[row][col] = float(input(subj + ': ')) print(scores)if __name__ == '__main__': main() 或者 1234567891011121314def main(): names = ['关羽', '张飞', '赵云', '马超', '黄忠'] subjs = ['语文', '数学', '英语'] scores = [[0] * 3 for _ in range(5)] for row, name in enumerate(names): print('请输入%s的成绩' % name) scores[row] = [0] * 3 for col, subj in enumerate(subjs): scores[row][col] = float(input(subj + ': ')) print(scores)if __name__ == '__main__': main() 如果对内存的使用不是很理解，可以看看PythonTutor网站上提供的代码可视化执行功能，通过可视化执行，我们可以看到内存是如何分配的，从而避免在使用嵌套列表或者复制对象时可能遇到的坑。 坑03 - 访问修饰符的坑用Python做过面向对象编程的人都知道，Python的类提供了两种访问控制权限，一种是公开，一种是私有（在属性或方法前加上双下划线）。而用惯了Java或C#这类编程语言的人都知道，类中的属性（数据抽象）通常都是私有的，其目的是为了将数据保护起来；而类中的方法（行为抽象）通常都是公开的，因为方法是对象向外界提供的服务。但是Python并没有从语法层面确保私有成员的私密性，因为它只是对类中所谓的私有成员进行了命名的变换，如果知道命名的规则照样可以直接访问私有成员，请看下面的代码。 123456789101112131415161718192021class Student(object): def __init__(self, name, age): self.__name = name self.__age = age def __str__(self): return self.__name + ': ' + str(self.__age)def main(): stu = Student('昊天', 28) # 'Student' object has no attribute '__name' # print(stu.__name) # 用下面的方式照样可以访问类中的私有成员 print(stu._Student__name) print(stu._Student__age)if __name__ == '__main__': main() Python为什么要做出这样的设定呢？用一句广为流传的格言来解释这个问题：“We are all consenting adults here”（我们都是成年人）。这句话表达了很多Python程序员的一个共同观点，那就是开放比封闭要好，我们应该自己对自己的行为负责而不是从语言层面来限制对数据或方法的访问。 所以在Python中我们实在没有必要将类中的属性或方法用双下划线开头的命名处理成私有的成员，因为这并没有任何实际的意义。如果想对属性或方法进行保护，我们建议用单下划线开头的受保护成员，虽然它也不能真正保护这些属性或方法，但是它相当于给调用者一个暗示，让调用者知道这是不应该直接访问的属性或方法，而且这样做并不影响子类去继承这些东西。 需要提醒大家注意的是，Python类中的那些魔法方法，如__str__、__repr__等，这些方法并不是私有成员哦，虽然它们以双下划线开头，但是他们也是以双下划线结尾的，这种命名并不是私有成员的命名，这一点对初学者来说真的很坑。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python惯例]]></title>
    <url>%2F2018%2F10%2F20%2FPython%E6%83%AF%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[前言“惯例”这个词指的是“习惯的做法，常规的办法，一贯的做法”，与这个词对应的英文单词叫“idiom”。由于Python跟其他很多编程语言在语法和使用上还是有比较显著的差别，因此作为一个Python开发者如果不能掌握这些惯例，就无法写出“Pythonic”的代码。下面我们总结了一些在Python开发中的惯用的代码。 让代码既可以被导入又可以被执行。 12if __name__ == '__main__': 用下面的方式判断逻辑“真”或“假”。 123if x:if not x: 好的代码： 123456name = 'jackfrued'fruits = ['apple', 'orange', 'grape']owners = &#123;'1001': '昊天', '1002': '王大锤'&#125;if name and fruits and owners: print('I love fruits!') 不好的代码： 123456name = 'jackfrued'fruits = ['apple', 'orange', 'grape']owners = &#123;'1001': '昊天', '1002': '王大锤'&#125;if name != '' and len(fruits) &gt; 0 and owners != &#123;&#125;: print('I love fruits!') 善于使用in运算符。 123if x in items: # 包含for x in items: # 迭代 好的代码： 1234name = 'Hao LUO'if 'L' in name: print('The name has an L in it.') 不好的代码： 1234name = 'Hao LUO'if name.find('L') != -1: print('This name has an L in it!') 不使用临时变量交换两个值。 12a, b = b, a 用序列构建字符串。 好的代码： 1234chars = ['j', 'a', 'c', 'k', 'f', 'r', 'u', 'e', 'd']name = ''.join(chars)print(name) # jackfrued 不好的代码： 123456chars = ['j', 'a', 'c', 'k', 'f', 'r', 'u', 'e', 'd']name = ''for char in chars: name += charprint(name) # jackfrued EAFP优于LBYL。 EAFP - Easier to Ask Forgiveness than Permission. LBYL - Look Before You Leap. 好的代码： 1234567d = &#123;'x': '5'&#125;try: value = int(d['x']) print(value)except (KeyError, TypeError, ValueError): value = None 不好的代码： 12345678d = &#123;'x': '5'&#125;if 'x' in d and isinstance(d['x'], str) \truetrueand d['x'].isdigit(): value = int(d['x']) print(value)else: value = None 使用enumerate进行迭代。 好的代码： 1234fruits = ['orange', 'grape', 'pitaya', 'blueberry']for index, fruit in enumerate(fruits):trueprint(index, ':', fruit) 不好的代码： 123456fruits = ['orange', 'grape', 'pitaya', 'blueberry']index = 0for fruit in fruits: print(index, ':', fruit) index += 1 用生成式生成列表。 好的代码： 1234data = [7, 20, 3, 15, 11]result = [num * 3 for num in data if num &gt; 10]print(result) # [60, 45, 33] 不好的代码： 1234567data = [7, 20, 3, 15, 11]result = []for i in data: if i &gt; 10: result.append(i * 3)print(result) # [60, 45, 33] 用zip组合键和值来创建字典。 好的代码： 12345keys = ['1001', '1002', '1003']values = ['昊天', '王大锤', '白元芳']d = dict(zip(keys, values))print(d) 不好的代码： 1234567keys = ['1001', '1002', '1003']values = ['昊天', '王大锤', '白元芳']d = &#123;&#125;for i, key in enumerate(keys): d[key] = values[i]print(d)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python编码习惯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python参考书籍]]></title>
    <url>%2F2018%2F10%2F20%2FPython%E5%8F%82%E8%80%83%E4%B9%A6%E7%B1%8D%2F</url>
    <content type="text"><![CDATA[入门读物 《Python基础教程》（Beginning Python From Novice to Professional） 《Python学习手册》（Learning Python） 《Python编程》（Programming Python） 《Python Cookbook》 《Python程序设计》（Python Programming: An Introduction to Computer Science） 《Modern Python Cookbook》 进阶读物 《Python核心编程》（Core Python Applications Programming） 《流畅的Python》（Fluent Python） 《Effective Python：编写高质量Python代码的59个有效方法》（Effective Python 59 Specific Ways to Write Better Python） 《Python设计模式》（Learning Python Design Patterns） 《Python高级编程》（Expert Python Programming） 《Python性能分析与优化》（Mastering Python High Performance） Web框架 《Django基础教程》（Tango with Django） 《轻量级Django》（Lightweight Django） 《Python Web开发：测试驱动方法》（Test-Driven Development with Python） 《Web Development with Django Cookbook》 《Test-Driven Development with Django》 《Django Project Blueprints 》 《Flask Web开发：基于Python的Web应用开发实战》（Flask Web Development: Developing Web Applications with Python） 《深入理解Flask》（Mastering Flask） 爬虫开发 《用Python写网络爬虫》（Web Scraping with Python） 《精通Python爬虫框架Scrapy》（Learning Scrapy） 《Python网络数据采集》（Web Scraping with Python） 《Python爬虫开发与项目实战》 《Python 3网络爬虫开发实战》 数据分析 《利用Python进行数据分析》（Python for Data Analysis） 《Python数据科学手册》（Python Data Science Handbook） 《Python金融大数据分析》（Python for Finance） 《Python数据可视化编程实战》（Python Data Visualization Cookbook） 《Python数据处理》（Data Wrangling with Python） 机器学习 《Python机器学习基础教程》（Introduction to Machine Learning with Python） 《Python机器学习实践指南》（Python Machine Learning Blueprints） 《Python Machine Learning Case Studies》 《Python机器学习实践：测试驱动的开发方法》（Thoughtful Machine Learning with Python A Test Driven Approach） 《Python机器学习经典实例》（Python Machine Learning Cookbook） 《TensorFlow：实战Google深度学习框架》]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈PEP8编码风格]]></title>
    <url>%2F2018%2F10%2F20%2FPEP%208%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[前言PEP是Python Enhancement Proposal的缩写，通常翻译为“Python增强提案”。每个PEP都是一份为Python社区提供的指导Python往更好的方向发展的技术文档，其中的第8号增强提案（PEP 8）是针对Python语言编订的代码风格指南。尽管我们可以在保证语法没有问题的前提下随意书写Python代码，但是在实际开发中，采用一致的风格书写出可读性强的代码是每个专业的程序员应该做到的事情，也是每个公司的编程规范中会提出的要求，这些在多人协作开发一个项目（团队开发）的时候显得尤为重要。我们可以从Python官方网站的PEP 8链接中找到该文档，下面我们对该文档的关键部分做一个简单的总结。 空格的使用 使用空格来表示缩进而不要用制表符（Tab）。这一点对习惯了其他编程语言的人来说简直觉得不可理喻，因为绝大多数的程序员都会用Tab来表示缩进，但是要知道Python并没有像C/C++或Java那样的用花括号来构造一个代码块的语法，在Python中分支和循环结构都使用缩进来表示哪些代码属于同一个级别，鉴于此Python代码对缩进以及缩进宽度的依赖比其他很多语言都强得多。在不同的编辑器中，Tab的宽度可能是2、4或8个字符，甚至是其他更离谱的值，用Tab来表示缩进对Python代码来说可能是一场灾难。 和语法相关的每一层缩进都用4个空格来表示。 每行的字符数不要超过79个字符，如果表达式因太长而占据了多行，除了首行之外的其余各行都应该在正常的缩进宽度上再加上4个空格。 函数和类的定义，代码前后都要用两个空行进行分隔。 在同一个类中，各个方法之间应该用一个空行进行分隔。 二元运算符的左右两侧应该保留一个空格，而且只要一个空格就好。 标识符命名PEP 8倡导用不同的命名风格来命名Python中不同的标识符，以便在阅读代码时能够通过标识符的名称来确定该标识符在Python中扮演了怎样的角色（在这一点上，Python自己的内置模块以及某些第三方模块都做得并不是很好）。 变量、函数和属性应该使用小写字母来拼写，如果有多个单词就使用下划线进行连接。 类中受保护的实例属性，应该以一个下划线开头。 类中私有的实例属性，应该以两个下划线开头。 类和异常的命名，应该每个单词首字母大写。 模块级别的常量，应该采用全大写字母，如果有多个单词就用下划线进行连接。 类的实例方法，应该把第一个参数命名为self以表示对象自身。 类的类方法，应该把第一个参数命名为cls以表示该类自身。 表达式和语句在Python之禅（可以使用import this查看）中有这么一句名言：“There should be one– and preferably only one –obvious way to do it.”，翻译成中文是“做一件事应该有而且最好只有一种确切的做法”，这句话传达的思想在PEP 8中也是无处不在的。 采用内联形式的否定词，而不要把否定词放在整个表达式的前面。例如if a is not b就比if not a is b更容易让人理解。 不要用检查长度的方式来判断字符串、列表等是否为None或者没有元素，应该用if not x这样的写法来检查它。 就算if分支、for循环、except异常捕获等中只有一行代码，也不要将代码和if、for、except等写在一起，分开写才会让代码更清晰。 import语句总是放在文件开头的地方。 引入模块的时候，from math import sqrt比import math更好。 如果有多个import语句，应该将其分为三部分，从上到下分别是Python标准模块、第三方模块和自定义模块，每个部分内部应该按照模块名称的字母表顺序来排列。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>PEP8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎访问我的个人博客]]></title>
    <url>%2F2018%2F10%2F17%2F%E6%AC%A2%E8%BF%8E%E8%AE%BF%E9%97%AE%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[网站说明有任何问题请联系我QQ: 1019217919]]></content>
      <categories>
        <category>py伊甸园</category>
      </categories>
      <tags>
        <tag>基于学习交流的目的搭建此平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复杂到简单你值得拥有]]></title>
    <url>%2F2018%2F10%2F17%2F%E7%94%A8%E5%87%BD%E6%95%B0%E8%BF%98%E6%98%AF%E7%94%A8%E5%A4%8D%E6%9D%82%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简介Perl语言的原作者Larry Wall曾经说过，伟大的程序员都有三个优点：懒惰、暴躁和自负。乍一看这三个词语没有一个是褒义词，但在程序员的世界里，这三个词有不同的意义。首先，懒惰会促使程序员去写一些省事儿的程序来辅助自己或别人更好的完成工作，这样我们就无需做那些重复和繁琐的劳动；同理能够用3行代码解决的事情，我们也绝不会写出10行代码来。其次，暴躁会让程序员主动的去完成一些你还没有提出的工作，去优化自己的代码让它更有效率，能够3秒钟完成的任务，我们绝不能容忍1分钟的等待。最后，自负会促使程序员写出可靠无误的代码，我们写代码不是为了接受批评和指责，而是为了让其他人来膜拜。 那么接下来就有一个很有意思的问题值得探讨一下，我们需要一个程序从输入的三个数中找出最大的那个数。这个程序对任何会编程的人来说都是小菜一碟，甚至不会编程的人经过10分钟的学习也能搞定。下面是用来解决这个问题的Python代码。 12345678910a = int(input('a = '))b = int(input('b = '))c = int(input('c = '))if a &gt; b:truethe_max = aelse:truethe_max = bif c &gt; the_max:truethe_max = cprint('The max is:', the_max) 但是我们刚才说了，程序员都是懒惰的，很多程序员都会使用三元条件运算符来改写上面的代码。 123456a = int(input('a = '))b = int(input('b = '))c = int(input('c = '))the_max = a if a &gt; b else bthe_max = c if c &gt; the_max else the_maxprint('The max is:', the_max) 需要说明的是，Python在2.5版本以前是没有上面代码第4行和第5行中使用的三元条件运算符的，究其原因是Guido van Rossum（Python之父）认为三元条件运算符并不能帮助 Python变得更加简洁，于是那些习惯了在C/C++或Java中使用三元条件运算符（在这些语言中，三元条件运算符也称为“Elvis运算符”，因为?:放在一起很像著名摇滚歌手猫王Elvis的大背头）的程序员试着用and和or运算符的短路特性来模拟出三元操作符，于是在那个年代，上面的代码是这样写的。 123456a = int(input('a = '))b = int(input('b = '))c = int(input('c = '))the_max = a &gt; b and a or bthe_max = c &gt; the_max and c or the_maxprint('The max is:', the_max) 但是这种做法在某些场景下是不能成立的，且看下面的代码。 123456a = 0b = -100# 下面的代码本来预期输出a的值，结果却得到了b的值# 因为a的值0在进行逻辑运算时会被视为False来处理print(True and a or b)# print(a if True else b) 所以在Python 2.5以后引入了三元条件运算符来避免上面的风险（上面代码被注释掉的最后一句话）。那么，问题又来了，上面的代码还可以写得更简短吗？答案是肯定的。 1234a = int(input('a = '))b = int(input('b = '))c = int(input('c = '))print('The max is:', (a if a &gt; b else b) if (a if a &gt; b else b) &gt; c else c) 但是，这样做真的好吗？如此复杂的表达式是不是让代码变得晦涩了很多呢？我们发现，在实际开发中很多开发者都喜欢过度的使用某种语言的特性或语法糖，于是简单的多行代码变成了复杂的单行表达式，这样做真的好吗？这个问题我也不止一次的问过自己，现在我能给出的答案是下面的代码，使用辅助函数。 12345678def the_max(x, y):truereturn x if x &gt; y else ya = int(input('a = '))b = int(input('b = '))c = int(input('c = '))print('The max is:', the_max(the_max(a, b), c)) 上面的代码中，我定义了一个辅助函数the_max用来找出参数传入的两个值中较大的那一个，于是下面的输出语句可以通过两次调用the_max函数来找出三个数中的最大值，现在代码的可读性是不是好了很多。用辅助函数来替代复杂的表达式真的是一个不错的选择，关键是比较大小的逻辑转移到这个辅助函数后不仅可以反复调用它，而且还可以进行级联操作。 当然，很多语言中比较大小的函数根本没有必要自己来实现（通常都是内置函数），Python也是如此。Python内置的max函数利用了Python对可变参数的支持，允许一次性传入多个值或者一个迭代器并找出那个最大值，所以上面讨论的问题在Python中也就是一句话的事，但是从复杂表达式到使用辅助函数简化复杂表达式这个思想是非常值得玩味的，所以分享出来跟大家做一个交流。 1234a = int(input('a = '))b = int(input('b = '))c = int(input('c = '))print('The max is:', max(a, b, c))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
